/**
 * To generate individuals randomly. Elements of a bit-string is generated by a standard Uniform distribution.
 */
void generatingIndividual(int * individuals,
                            const size_t dimension,
                            IOHprofiler_random_state_t *random_generator){
  size_t i;
  for(i = 0; i < dimension; ++i){
    individuals[i] = (int)(IOHprofiler_random_uniform(random_generator) * 2);
  }
}

/**
 * To copy an individual "old" to "new", the length of the bit-string is given by "dimension".
 */
void CopyIndividual(int * old, int * new, const size_t dimension){
  size_t i;
  for(i = 0; i < dimension; ++i){
    new[i] = old[i];
  }
}

/**
 * To sample a random value by a Binomial distribution with "n" trials and a given "probability".
 */
size_t randomBinomial(size_t n, double  probability,IOHprofiler_random_state_t *random_generator)
{
    size_t r, i;
    r = 0;
    for(i = 0; i < n; ++i){
        if(IOHprofiler_random_uniform(random_generator) < probability)
        {
            ++r;
        }
    }
    return r;
}

/**
 * Mutation Operator.
 * "l" is the number of bits to be flipped, which is sample by Binomial distribution.
 * "l" positions are randomly selected by a uniform distribution.
 * A resampling strategy is applied to make sure that "l" is larger than 0.
 */
size_t mutateIndividual(int * individual,
                      const size_t dimension,
                      double mutation_rate,
                      IOHprofiler_random_state_t *random_generator){
  size_t i, h, l;
  int flag,temp;
  int * flip;

  l = randomBinomial(dimension,mutation_rate,random_generator);
  if (l == 0) {
    l = 1;
  }

  flip = IOHprofiler_allocate_int_vector(l);
  for(i = 0; i < l; ++i){
    while(1){
      flag = 0;
      temp = (int)(IOHprofiler_random_uniform(random_generator) * dimension);
      for(h = 0; h < i; ++h)
      {
        if(temp == flip[h]){
          flag = 1;
          break;
        }
      }
      if(flag == 0)
        break;
    }
    flip[i] = temp;
  }

  for(i = 0; i < l; ++i){
    individual[flip[i]] =  ((int)(individual[flip[i]] + 1) % 2);
  }
  IOHprofiler_free_memory(flip);
  return l;
}
